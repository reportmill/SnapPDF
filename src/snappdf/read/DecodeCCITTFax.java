/*
 * Copyright (c) 2010, ReportMill Software. All rights reserved.
 */
package snappdf.read;
import java.io.*;
import java.util.Map;

import snappdf.PDFException;

/**
 * Decodes CCITTFax.
 */
public class DecodeCCITTFax {

    // The bit stream
    byte _allBits[];
    int _bitOffset;
    int _mark;

    // decode parameters
    int _K, _rows, _columns;
    int _numDamagedRowsAllowed;
    boolean _byteAligned;
    boolean _eolRequired;
    boolean _eoblockRequired;
    boolean _blackIsOne;


    /**
     * Decode a single image.
     */
    public static byte[] bytesForCCITTFaxDecode(byte bytes[], int offset, int len, int K, int rows, int columns,
                                                boolean byteAligned, boolean eolRequired, boolean eoblockRequired, boolean blackIsOne, int allowedDamagedRows)
    {
        DecodeCCITTFax ccittFaxDecode = new DecodeCCITTFax(bytes, offset, K, rows, columns, allowedDamagedRows,
                byteAligned, eolRequired, eoblockRequired, blackIsOne);
        return ccittFaxDecode.decodeStream();
    }

    /**
     * Utility method to create a CCITTFaxDecoder from the stream's decodeParameters dictionary.
     */
    public static DecodeCCITTFax createDecoder(Map params, byte bytes[], int offset, int len)
    {
        // Every value has a default
        int K = 0;
        boolean eolRequired = false;
        boolean byteAligned = false;
        boolean eoblockRequired = true;
        boolean blackIsOne = false;
        int allowedDamagedRows = 0;
        int rows = 0, columns = 1728;

        // pull the parameter values out of the dictionary
        if (params != null) {
            Object pval = params.get("K");
            if (pval instanceof Number)
                K = ((Number) pval).intValue();
            pval = params.get("EndOfLine");
            if (pval instanceof Boolean)
                eolRequired = ((Boolean) pval).booleanValue();
            pval = params.get("EncodedByteAlign");
            if (pval instanceof Boolean)
                byteAligned = ((Boolean) pval).booleanValue();
            pval = params.get("Columns");
            if (pval instanceof Number)
                columns = ((Number) pval).intValue();
            pval = params.get("Rows");
            if (pval instanceof Number)
                rows = ((Number) pval).intValue();
            pval = params.get("EndOfBlock");
            if (pval instanceof Boolean)
                eoblockRequired = ((Boolean) pval).booleanValue();
            pval = params.get("BlackIs1");
            if (pval instanceof Boolean)
                blackIsOne = ((Boolean) pval).booleanValue();
            pval = params.get("DamagedRowsBeforeError");
            if (pval instanceof Number)
                allowedDamagedRows = ((Number) pval).intValue();
        }

        // return the new decoder
        return new DecodeCCITTFax(bytes, offset, K, rows, columns, allowedDamagedRows,
                byteAligned, eolRequired, eoblockRequired, blackIsOne);
    }

    /**
     * Creates DecodeCCITTFax.
     */
    public DecodeCCITTFax(byte bits[], int offset, int k, int rows, int columns, int numdamagedrows,
                          boolean aligned, boolean eolrequired, boolean eoblockrequired, boolean blackisone)
    {
        _allBits = bits;
        _bitOffset = _mark = offset * 8;
        _K = k;
        _rows = rows;
        _columns = columns;
        _numDamagedRowsAllowed = numdamagedrows;
        _byteAligned = aligned;
        _eolRequired = eolrequired;
        _eoblockRequired = eoblockrequired;
        _blackIsOne = blackisone;
    }

    /**
     * These arrays are binary trees of run lengths.  Branch nodes of the tree are represented
     * by two consectutive ints in the tree.  If the value in the tree is positive,
     * the child node is a branch node, and the number represents the index in this
     * table where that child node can be found.
     * If the value is negative, it is a leaf node and the run length for the bit string
     * is the absolute value of that number.
     * Two special values exist in the table. -9999 indicates a bit string that isn't
     * represented in the table. -1000 is the EOL.
     * Run lengths 0-63 encode that many white or black pixels.
     * Run lengths >63 encode that many + the value of the next code (which should be <64)
     * Run length 2560 encodes 2560 + next 1 or 2 codes, and may be repeated many times.
     * <p>
     * searching the table is a simple matter of walking through the bits:
     * <p>
     * int table_index=0;
     * do {
     * if (getNextBit()) ++table_index; // choose left node for 0 bit, right node for 1 bit
     * table_index=ccittRunLengths[table_index]; // get the node
     * } while(table_index>0); //continue walking down the tree until a negative (or 0) number is found
     * return -table_index;
     * <p>
     * These arrays were generated by CCITTreeBuilder.java
     */
    static int ccittRunLengths_white[] = {
            2, 192, 4, 116, 6, 80, 8, 60, 10, 54, 12, 50, 14, 48, 16, 24,
            18, -9999, 20, -9999, 22, -9999, -9999, -1000, 26, 38, 28, 32, -1792, 30, -1984, -2048,
            34, 36, -2112, -2176, -2240, -2304, 40, 42, -1856, -1920, 44, 46, -2368, -2432, -2496, -2560,
            -29, -30, 52, -22, -45, -46, 56, -13, -23, 58, -47, -48, 62, 74, 64, 68,
            -20, 66, -33, -34, 70, 72, -35, -36, -37, -38, 76, -1, -19, 78, -31, -32,
            82, 102, 84, 90, -12, 86, 88, -26, -53, -54, 92, 98, 94, 96, -39, -40,
            -41, -42, 100, -21, -43, -44, 104, -10, 106, 110, -28, 108, -61, -62, 112, 114,
            -63, 0, -320, -384, 118, 156, 120, 136, -11, 122, 124, 128, -27, 126, -59, -60,
            130, -18, 132, 134, -1472, -1536, -1600, -1728, 138, 148, 140, 144, -24, 142, -49, -50,
            146, -25, -51, -52, 150, -192, 152, 154, -55, -56, -57, -58, 158, -2, 160, 170,
            -1664, 162, 164, 166, -448, -512, 168, -640, -704, -768, 172, 184, 174, 178, -576, 176,
            -832, -896, 180, 182, -960, -1024, -1088, -1152, 186, -256, 188, 190, -1216, -1280, -1344, -1408,
            194, 206, 196, 200, -3, 198, -128, -8, 202, -4, -9, 204, -16, -17, 208, 214,
            -5, 210, 212, -64, -14, -15, -6, -7};

    static int ccittRunLengths_black[] = {
            2, 214, 4, 212, 6, 210, 8, 206, 10, 164, 12, 114, 14, 48, 16, 24,
            18, -9999, 20, -9999, 22, -9999, -9999, -1000, 26, 38, 28, 32, -1792, 30, -1984, -2048,
            34, 36, -2112, -2176, -2240, -2304, 40, 42, -1856, -1920, 44, 46, -2368, -2432, -2496, -2560,
            50, 82, 52, 64, -18, 54, 56, 60, -52, 58, -640, -704, 62, -55, -768, -832,
            66, 76, 68, 72, -56, 70, -1280, -1344, 74, -59, -1408, -1472, 78, -24, -60, 80,
            -1536, -1600, 84, 100, 86, 92, -25, 88, 90, -320, -1664, -1728, 94, 96, -384, -448,
            98, -53, -512, -576, 102, -64, 104, 108, -54, 106, -896, -960, 110, 112, -1024, -1088,
            -1152, -1216, 116, 140, -13, 118, 120, 132, 122, 126, -23, 124, -50, -51, 128, 130,
            -44, -45, -46, -47, 134, -16, 136, 138, -57, -58, -61, -256, 142, -14, 144, 152,
            -17, 146, 148, 150, -48, -49, -62, -63, 154, 160, 156, 158, -30, -31, -32, -33,
            162, -22, -40, -41, 166, 168, -10, -11, 170, -12, 172, 186, -15, 174, 176, 182,
            178, 180, -128, -192, -26, -27, 184, -19, -28, -29, 188, 200, 190, 194, -20, 192,
            -34, -35, 196, 198, -36, -37, -38, -39, 202, 0, -21, 204, -42, -43, 208, -7,
            -9, -8, -6, -5, -1, -4, -3, -2};


    // Special 1D encoding flags
    public static final int EndOfTheLine = -1000;
    // 2D encoding modes
    public static final int PassMode = 1;
    public static final int Horizontal = 2;
    public static final int Vertical0 = 3;
    public static final int VerticalRight1 = 4;
    public static final int VerticalRight2 = 5;
    public static final int VerticalRight3 = 6;
    public static final int VerticalLeft1 = 7;
    public static final int VerticalLeft2 = 8;
    public static final int VerticalLeft3 = 9;
    public static final int UncompressedMode = 10;

    // 2D encoding.  Negative integers correspond to one of the modes above.
    static int ccittCodeWords2d[] = {
            2, -3, 4, 34, 6, -2, 8, -1, 10, 32, 12, 30, 14, 24, 16, -9999,
            18, -9999, 20, -9999, 22, -9999, -9999, -1000, -9999, 26, -9999, 28, -9999, -10, -9, -6,
            -8, -5, -7, -4};


    // Read the next codeword from the stream.  table is one of the above trees.
// Returns the codeword or -1 for EOF
    public int getNextCodeword(int table[])
    {
        int byteOffset = _bitOffset / 8;
        int mask = 1 << (7 - (_bitOffset % 8));
        int abyte;
        int treeindex = 0;
        if (byteOffset >= _allBits.length)
            return -1;
        abyte = _allBits[byteOffset];
        while (true) {
            if ((abyte & mask) != 0)
                ++treeindex;
            treeindex = table[treeindex];
            ++_bitOffset;
            if (treeindex == -9999)
                throw new PDFException("Error decoding CCITTFaxDecode stream");
            else if (treeindex == EndOfTheLine)
                return EndOfTheLine;
            else if (treeindex <= 0)
                return -treeindex;
            mask >>= 1;
            if (mask == 0) {
                if (++byteOffset >= _allBits.length)
                    // incomplete codeword, but no more bits.  returns eof
                    return -1;
                abyte = _allBits[byteOffset];
                mask = 128;
            }
        }
    }

    /**
     * Interprets next n codewords as an integer.
     * Rules are: numbers less than 64 are low digits.
     * numbers between 64 and 2559 require one additional low digit.
     * 2560 requires an additional number, containing any number of digits.
     **/
    public int getNextInt(int table[])
    {
        boolean need_more_digits = false;
        int i = 0, c;

        while (true) {
            c = getNextCodeword(table);
            if (c < 0) { // should only happen for EOL or EOF
                throw new PDFException("premature EOL encountered in CCITTFaxDecode stream");
            }
            if (need_more_digits) {
                if (c > 63)
                    throw new PDFException("Error decoding CCITTFaxDecodeStream");
                i += c;
                return i;
            }
            else {
                if (c <= 63)
                    return i + c;
                i += c;
                if (c != 2560)
                    need_more_digits = true;
            }
        }
    }

    /**
     * Skips over any extra padding bits at the end of a byte.
     */
    public void byteAlignStream()
    {
        _bitOffset = (_bitOffset + 7) & ~7;
    }

    /**
     * Mark the current point in the bitstream.  Use backup() to return to this point.
     */
    public void mark()
    {
        _mark = _bitOffset;
    }

    /**
     * Back the stream up to the marked position
     */
    public void backup()
    {
        _bitOffset = _mark;
    }

    /**
     * Decode the entire image at once
     */
    public byte[] decodeStream()
    {
        ByteArrayOutputStream outstream = new ByteArrayOutputStream(64);
        try {
            decodeStream(outstream);
        }
        catch (Exception e) {
            System.err.println("Error decoding CCITTFax image stream");
            return null;
        }
        return outstream.toByteArray();
    }

    /**
     * Decode, writing image bytes to outstream
     */
    public void decodeStream(OutputStream outstream) throws PDFException, IOException
    {
        byte scanline[] = new byte[_columns];
        int initialStreamPosition = _bitOffset;

        // Pure 1D encoding
        if (_K == 0) {
            while (decodeScanline1D(scanline)) {
                writeScanline(outstream, scanline);
                if (_byteAligned)
                    byteAlignStream();
            }
        }
        //Pure 2D encoding
        else if (_K < 0) {
            // 2D encoding always uses the last scanline as a reference.
            // For the first scanline, the reference is a pure white scanline
            for (int i = 0; i < _columns; ++i)
                scanline[i] = 1;
            while (decodeScanline2D(scanline)) {
                writeScanline(outstream, scanline);
                if (_byteAligned)
                    byteAlignStream();
            }
        }
        else {
            // Mixed mode takes 1 1d line, followed by K-1 2d lines.
            // The only trick would be to check how the end of stream is handled
            _bitOffset = initialStreamPosition;
            throw new PDFException("Mixed 1d&2d CCITTFaxDecode mode not implemented yet");
        }

        outstream.flush();

        // reset the input stream so the next call to decodeStream will start over
        _bitOffset = initialStreamPosition;
    }

    // There are two different encoding schemes which can used together in a bit stream.
// The 1D encoding (Group 3) takes a scanline and alternates between black and white
// runs by encoding a run length code.
// The 2D encoding (Group 4) works on mulitple scanlines by encoding a scanline with
// 1D encoding (for mixed Group 3 & 4 mode) or by initializing to white (Pure Group 4)
// and then encoding later scanlines using codes to specify diffrerences
// from previous scanlines.
// 
// Returns true for success, false for eof.
    public boolean decodeScanline1D(byte outdata[])
    {
        int codeword_trees[][] = {ccittRunLengths_black, ccittRunLengths_white};
        int atree[];
        int x = 0;
        int runcolor = 1; //0 for black, 1 for white
        int codeword;
        int runlength = 0;
        boolean need_more_digits = false;
        int num_2560s = 0;
        int num_eols = 0;

        atree = codeword_trees[runcolor];
        // outdata is assumed to be big enough to hold x 8bit pixels, so no bounds checking on the array is done
        while (x < _columns) {
            codeword = getNextCodeword(atree);

            if (codeword == EndOfTheLine) {
                //EOL before getting any row data may be part of an EndOfBlock (6 EOLs)
                if (x == 0) {
                    for (num_eols = 1; num_eols < 6; ++num_eols) {
                        codeword = getNextCodeword(atree);
                        if (codeword == -1) return false;
                        else if (codeword != EndOfTheLine)
                            throw new PDFException("Unexpected EOL in CCITTFaxDecode stream");
                    }
                    // got an eob - return false (for end of data)
                    return false;
                }
                else // EOL in the middle of the row is an error
                    throw new PDFException("Unexpected EOL in CCITTFaxDecodeStream");
            }
            //large run lengths can be encoded as 2560+2560+2560...+m, where m is 1 or 2 digit code
            else if (codeword == 2560) {
                if (need_more_digits)
                    throw new PDFException("Error decoding CCITTFaxDecode stream");
                ++num_2560s;
            }
            //Run lengths between 64 & 2560 consist of 2 codes, and this code is the high digit
            else if (codeword >= 64) {
                runlength = codeword;
                if (need_more_digits)
                    throw new PDFException("Error decoding CCITTFaxDecode stream");
                need_more_digits = true;
            }
            //A run length between 0 and 63
            else if (codeword != -1) {
                // If previous code word was for a high digit, add the low digit in
                if (need_more_digits)
                    runlength += codeword;
                else
                    runlength = codeword;
                // add in chain of 2560s
                runlength += 2560 * num_2560s;
                if (x + runlength > _columns)
                    throw new PDFException("Error decoding CCITTFaxDecode stream");
                // fill the output with the colors.  Notice it's 8bits per pixel, 2 colors
                for (int r = 0; r < runlength; ++r)
                    outdata[x++] = (byte) runcolor;

                // reset everthing for the next run
                runcolor = 1 - runcolor;
                atree = codeword_trees[runcolor];
                need_more_digits = false;
                num_2560s = 0;
            }
            //EOF
            else {
                if (x == 0)
                    return false;
                else
                    throw new PDFException("premature end of CCITTFaxDecode stream");
            }
        }
        // Filled the scanline.  Check for EOL
        mark();
        if (getNextCodeword(atree) != EndOfTheLine) {
            if (_eolRequired)
                throw new PDFException("No End-of-line marker found in CCITTFaxDecode stream");
            else
                // It wasn't required to be there, so back up to the last point in the stream.
                backup();
        }
        return true;

    }

    //Used by 2D decoder
//Finds b1 & b2 (returned as elements b[1] and b[2], respectively)
//on the reference scanline, starting from pixel a0
    public void locateReferenceMarks(byte scanline[], int a0, byte a0color, int b[])
    {
        int x;
        int b0 = a0 + 1;
        byte bcolor = 0, previous;
        // b1 is defined as first 'changing element' to the right of a0 which
        // is a different color from a0
        // A changing element is a pixel whose color is different from the
        // pixel to its left.
        // The pixel at -1 is defined to be white, so scanline[0] is a changing
        // element if it is black.

        //search for b1
        for (x = b0; x < scanline.length; ++x) {
            bcolor = scanline[x];
            previous = x == 0 ? 1 : scanline[x - 1];
            if (bcolor != previous) {
                // a changing element.  If its different from a0color,
                // we've found b1
                if (bcolor != a0color) {
                    b[1] = x;
                    break;
                }
            }
        }
        // If b1 not found (all pixels were the same color, for instance) set
        // b1 & b2 to the pixel after the last one in the line.
        if (x == scanline.length) {
            b[1] = b[2] = x;
        }
        else {
            //find b2
            while (++x < scanline.length)
                if (scanline[x] != bcolor) {
                    b[2] = x;
                    break;
                }
            if (x == scanline.length)
                b[2] = x;
        }
    }

    /**
     * 2D decoder.  outdata is a buffer which the new scanline will be written to.
     * On input, however, outdata should have the bits for the previous scanline.
     * The 2D encoder will include codewords which make reference to the previous
     * scanline.
     * For the very first scaneline, outdata should be initialized to all white.
     **/
    public boolean decodeScanline2D(byte outdata[])
    {
        int codeword_trees[][] = {ccittRunLengths_black, ccittRunLengths_white};
        int x = 0;
        // a0 starts off to the left of first pixel and is defined as white
        int a0 = -1;
        byte a0Color = 1;
        int a1, a2;
        int b[] = new int[3];
        int codeword;


        while (x < _columns) {
            codeword = getNextCodeword(ccittCodeWords2d);
            //EOD due to unused bits in last byte of data
            if ((codeword < 0) && (x == 0)) return false;
            //EOFB is 2 EOLs in a row.  No other EOLs are valid in 2d mode
            if (codeword == EndOfTheLine) {
                if ((x == 0) && (getNextCodeword(ccittCodeWords2d) == EndOfTheLine))
                    return false;
                else
                    throw new PDFException("EOL encountered in CCITTFaxDecode stream");
            }
            // Horizontal mode explicity codes a0a1 and a1a2
            else if (codeword == Horizontal) {
                if (a0 == -1) // first pixel on line
                    a0 = 0;
                a1 = a0 + getNextInt(codeword_trees[a0Color]);
                a2 = a1 + getNextInt(codeword_trees[1 - a0Color]);

                while (x < a1)
                    outdata[x++] = a0Color;
                while (x < a2)
                    outdata[x++] = (byte) (1 - a0Color);
                a0 = a2;
            }
            else if (codeword == UncompressedMode) {
                throw new PDFException("UncompressedMode not implemented yet");
            }
            else {
                // The rest of these codes make reference to b[1] & b[2] on the line above
                locateReferenceMarks(outdata, a0, a0Color, b);
                if (codeword == PassMode) {
                    while (x < b[2])
                        outdata[x++] = a0Color;
                    a0 = b[2];
                }
                else {
                    switch (codeword) {
                        case Vertical0:
                            break;
                        case VerticalRight1:
                            b[1] += 1;
                            break;
                        case VerticalRight2:
                            b[1] += 2;
                            break;
                        case VerticalRight3:
                            b[1] += 3;
                            break;
                        case VerticalLeft1:
                            b[1] -= 1;
                            break;
                        case VerticalLeft2:
                            b[1] -= 2;
                            break;
                        case VerticalLeft3:
                            b[1] -= 3;
                            break;
                        default:
                            throw new PDFException("Invalid data in CCITTFaxDecode stream");
                    }
                    // I don't think this should ever happen in a valid stream
                    if (b[1] > outdata.length)
                        b[1] = outdata.length;
                    a0 = b[1];
                    while (x < b[1])
                        outdata[x++] = a0Color;
                    a0Color = (byte) (1 - a0Color);
                }
            }
        }
        return true;
    }

    /**
     * Write the decoded scanline to a stream.
     */
    public void writeScanline(OutputStream out, byte scanline[]) throws IOException
    {
        out.write(scanline);
    }

    /**
     * Get the width of the decompressed image
     */
    public int getWidth()
    {
        return _columns;
    }

    /**
     * Get the height of the decompressed image
     */
    public int getHeight()
    {
        return _rows;
    }

    /**
     * Returns whether a pixel value or 1 should be interpreted as black or white
     */
    public boolean blackIsOne()
    {
        return _blackIsOne;
    }

    /**
     * Set the dimensions manually
     */
    public void setDimensions(int width, int height)
    {
        // We don't necessarily know what the height of the
        // decompressed image is until after decompression,
        // but we do know the width.
        if (width != _columns)
            throw new PDFException("Illegal values for CCITTFaxDecode image width");

        // If we already think we know what the rows are, _rows will be non-zero
        if ((_rows != 0) && (_rows != height))
            throw new PDFException("Illegal values for CCITTFaxDecode image height");

        _rows = height;
    }

}
